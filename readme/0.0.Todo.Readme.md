# Developer Experience (DX)

| Developer Experience (DX) Task ID | Task Details                                                                                               |
|-----------------------------------|------------------------------------------------------------------------------------------------------------|
| DX-01                             | Implement tools in makefile for IDE configuration (.idea, .vscode) with a `dx` prefix on the make command. |

---
```
passage/
├── package.json
├── bun.lock                 # lock down dependencies
├── .npmrc                   # lock down registry / mirror
├── .env.example             # env vars template (no secrets checked in)
├── .gitignore
├── .dockerignore
├── Dockerfile
├── docker-compose.yml
├── sbom/                    # generated SBOMs (CycloneDX, SPDX)
│   └── sbom.json
├── config/
│   ├── default.json         # sane defaults
│   ├── production.json      # production overrides
│   ├── security.json        # security policies (CORS, CSP, rate limits)
│   └── providers.json       # upstream OIDC/OAuth2 provider configs
├── src/
│   ├── app.ts               # Express app entrypoint
│   ├── server.ts            # server bootstrap
│   ├── middleware/          # security and auth middlewares
│   │   ├── helmet.ts        # sets CSP / headers
│   │   ├── rateLimit.ts     # throttling
│   │   ├── requestLogger.ts # pino logger
│   │   ├── errorHandler.ts  # central error handling
│   │   └── validator.ts     # ajv/zod input validation
│   ├── routes/
│   │   ├── auth.routes.ts   # OAuth2 endpoints (/authorize, /token, /introspect)
│   │   ├── user.routes.ts   # userinfo, profile, etc.
│   │   ├── provider.routes.ts # upstream provider callbacks
│   │   └── health.routes.ts # /healthz for monitoring
│   ├── controllers/
│   │   ├── auth.controller.ts
│   │   ├── user.controller.ts
│   │   └── provider.controller.ts # upstream provider integration
│   ├── services/
│   │   ├── token.service.ts      # issue/validate JWTs
│   │   ├── jwks.service.ts       # key rotation + JWKS endpoint
│   │   ├── crypto.service.ts     # crypto primitives (RSA, EC, Argon2, PQ later)
│   │   ├── user.service.ts       # user persistence + auth checks
│   │   ├── provider.service.ts   # upstream provider abstractions
│   │   ├── discovery.service.ts  # OIDC discovery for upstream providers
│   │   └── federation.service.ts # token exchange & identity federation
│   ├── utils/
│   │   ├── logger.ts
│   │   ├── env.ts
│   │   └── errors.ts
│   ├── models/
│   │   ├── user.model.ts
│   │   ├── client.model.ts
│   │   ├── token.model.ts
│   │   └── provider.model.ts     # upstream provider configurations
│   ├── db/
│   │   ├── index.ts             # database connector (Postgres/Mongo)
│   │   └── migrations/          # schema migrations
│   ├── keys/
│   │   ├── jwks.json            # public keys for JWKS endpoint
│   │   └── private.pem          # private key (dev only; prod = HSM/Vault)
│   └── tests/
│       ├── auth.test.ts
│       ├── token.test.ts
│       ├── user.test.ts
│       └── provider.test.ts     # upstream provider integration tests
├── scripts/
│   ├── gen-keys.ts              # helper to rotate keys
│   ├── sbom-gen.sh              # generate SBOM
│   └── sync-providers.ts        # sync upstream provider configs
├── .github/
│   └── workflows/
│       └── ci.yml               # lint, test, snyk, sbom, build, deploy
```


---

---

🔐 High-Security Express OAuth2 Stack

1. Runtime & Dependency Management

Runtime: Node.js LTS (or Bun if you want bleeding edge performance).

Package manager:

Use Bun as a package manager and runtime (blazing fast for Express.js, and PostGres).

Enforce lockfiles (bun.lock) → prevents dependency drift.


Supply chain security:

Private package registry (e.g., Verdaccio, GitHub Packages, or JFrog Artifactory).

Enable Snyk or npm audit in CI/CD.

Generate SBOMs (CycloneDX or SPDX) for every release.

Optionally enable sigstore/cosign for package signing verification.


---

2. Core Web Framework

Express.js (stable, small attack surface).

Harden with:

helmet → sets secure HTTP headers.

cors → strict cross-origin policy.

express-rate-limit → request throttling.

hpp → HTTP Parameter Pollution protection.

compression → safe GZIP/deflate with limits.




---

3. OAuth2 / JWT Layer

OAuth2 implementation:

Use oidc-provider (battle-tested OpenID Connect & OAuth2 provider for Node).

OR build minimal flows with node-oauth2-server if you want hands-on control.


Token signing & encryption:

Use jose (the modern JOSE/JWT/JWK library in Node).

Configure tokens as:

Signed: RS256 / ES256 (RSA/ECDSA today).

PQ-ready (future research): hybrid RS256 + Dilithium or ES256 + Falcon.


Encrypt sensitive JWT payloads with JWE (AES-GCM), not just JWS.

Rotate keys automatically via JWKS endpoint.




---

4. Middleware Security Controls

Audit logging → append-only logs (use pino for structured logging).

Request validation → zod or ajv for strict JSON schema validation.

Authentication middleware:

Validate JWTs locally with jose.

Use Proof-of-Possession tokens (PoP) instead of bearer tokens for higher security.


RBAC/ABAC middleware → central policy enforcement (e.g., Casbin).



---

5. Crypto Enhancements

Use libsodium (via libsodium-wrappers in Node) for strong primitives.

Default to Argon2id for password hashing (better than bcrypt).

PQ crypto research: integrate liboqs (Open Quantum Safe) bindings to experiment with Kyber/Dilithium.



---

6. Infrastructure Hardening

TLS: Terminate at reverse proxy (nginx, Envoy, or Cloudflare edge). Use TLS 1.3.

mTLS support: Mutual TLS between services.

Containers:

Run in Docker with distroless base image.

Scan images with Trivy or Grype.


Secrets:

Never store in code → use Vault, SSM, or Doppler.

Rotate regularly.




---

7. Monitoring & Defense

Rate limiting + anomaly detection: Fail2ban + express-rate-limit.

Metrics: Prometheus + Grafana (OAuth2 metrics: token issuance rate, failures).

Runtime protection: Falco (container intrusion detection).

Dependency scanning: GitHub Dependabot + Snyk CI/CD integration.



---

8. Development Workflow

TypeScript everywhere → strict mode.

ESLint + Prettier → clean, enforceable style.

CI/CD pipeline:

Lint → Test → Security scan (Snyk/Trivy) → SBOM → Build → Deploy.


Unit + integration tests: Mocha/Jest + Supertest for HTTP flow coverage.



---

🚀 Result

With this stack you’ll have:

Express.js at the core (lean + scalable).

oidc-provider/jose for OAuth2 + JWT flows.

bun + SBOM + private registry for dependency security.

Helmet, rate limits, Argon2, JWKS rotation for hardened app security.

Hooks to experiment with PQC later via liboqs bindings.


This is the kind of boilerplate that:

Recruiters will look at and think “this dev knows real enterprise security.”

Can grow into a true product (post-quantum OAuth2 middleware).


---

Got it — here’s a basic, high-security file layout tree for your Express OAuth2 boilerplate. It’s structured like something an enterprise engineer would expect: separation of concerns, security hooks, and extensibility for PQ crypto later.

--- 

Highlights

src/middleware/ → all security middlewares live here.

src/services/crypto.service.ts → abstract crypto so you can swap RSA → PQ later.

src/services/jwks.service.ts → handles key rotation + JWKS endpoint publishing.

keys/ → dev-only; in prod, you’d pull from Vault/HSM.

scripts/sbom-gen.sh → enforces secure build practices (generates Software Bill of Materials).

tests/ → unit + integration tests for auth/token flows.

CI/CD (.github/workflows) → runs lint → test → security scan (snyk) → SBOM → build.



---

✅ This layout is lean enough for a solo dev but structured enough to look enterprise-ready. It also future-proofs you for PQ crypto experiments because all cryptography is abstracted in one service (crypto.service.ts).


---

Do you want me to also give you a sample app.ts skeleton (Express with security middlewares + route mounts) so you can bootstrap this project in like 10 minutes?


